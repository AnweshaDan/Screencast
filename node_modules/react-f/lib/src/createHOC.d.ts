import * as React from "react";
import { HOCvoid, HOCOptions, HOC } from "./HOC";
export declare type ComponentClass<P> = React.ComponentClass<P> | React.StatelessComponent<P>;
export declare type HocImplementationClass<CP> = React.ComponentClass<any> & {
    new (...args: any[]): {
        getChildProps(): CP;
    };
};
/**
 * Arguments to create a HOC from
 */
export declare type Arguments<O, CP> = {
    /** the HOCs name
     *
     * used for debugging, should be unique
     */
    name: string;
    /**
     * The default options that HOC.props(foo) returns,
     * if foo does not have access to the real HOC props,
     * e.g. if foo is not a child of HOC
     */
    defaultOptions?: Partial<O>;
    /**
     * Other HOC to wrap this HOC in
     *
     * this can be used if one wants to combine some exsiting HOCs and
     * also wants to provide additional methods
     *
     * @example:
     * wrappers: [MyFirstHOC(), MySecondHOC({foo: "bar"})]
     *
     * for an example see the build-in Form/Validation HOC
     */
    wrappers?: Array<HOC<any>>;
    /**
     * IDs of HOCs whose props should be extracted from react's context
     *
     * e. g. used to gain access to the API of another HOC
     * that is at a higher position in the dom-tree.
     *
     * @example:
     * contextTypes: [Foo.ID],
     * (...)
     * Foo.props(this.context) // if foo wasn't declared above, this would return Foo's defaultProps
     */
    contextTypes?: string[];
    /**
     * the HOC implementation
     *
     * should be an es-6 class that extends React.Component<ParentProps>
     * where ParentProps are the props that the author expects later users to
     * assign to the HOC / the wrapped component
     *
     * @example:
     * // CustomHOC.ts
     * interface ParentProps {
     *  foo: string
     * }
     *
     * // dumbcomponent.tsx
     * @CustomHOC class DumbComponent extends React.Component (...)
     *
     * // usage.tsx
     *
     * <DumbComponent foo="bar" /> // this is the 'foo'-prop that the CustomHOC expects
     */
    class?: HocImplementationClass<CP>;
    /**
     * A function that gets the HOCs options and should return the HOC implementation
     *
     * Is an alternative to the class property
     */
    getClass?: ((options: O) => HocImplementationClass<CP>);
    /**
     * What to return if some user calls YourHOC.props(obj) if obj is not wrapped with YourHOC.
     *
     * This can be used to minimize the occurences of null pointer exceptions.
     */
    defaultChildProps?: CP;
};
/**
 * Creates a HOC / class decorator
 *
 * This function creates and returns a higher-order-component
 * which later can wrap an ordinary component to grant its own capabilities
 * to the wrapped component
 *
 * conceptually, the HOC encapsulates a specific bit of logic
 * and provides only the public API to the using components
 * e. g. the HOC may manage a piece of informaiton like
 * 'was the wrapped component already clicked' and only provides
 * a method 'setClicked(boolean)' and a property 'wasClicked'.
 *
 * @param args see @see Arguments for more information
 * @return a higher-order-component which later can wrap an ordinary component
 * to
 */
export default function createHOC<CP>(args: Arguments<never, CP>): HOCvoid<CP>;
export default function createHOC<O, CP>(args: Arguments<O, CP>): HOCOptions<O, CP>;
